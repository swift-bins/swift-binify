import Foundation

/// Generates a Package.swift that wraps built xcframeworks
struct PackageGenerator {
    
    private let dylibsPath = "/tmp/swift-binify-dylibs"
    
    /// Generate a Package.swift for the built xcframeworks
    /// - Parameters:
    ///   - packageInfo: The analyzed package info
    ///   - builtProducts: Names of the successfully built targets/xcframeworks
    ///   - outputDir: Where to write the Package.swift
    func generate(
        packageInfo: PackageInfo,
        builtProducts: [String],
        outputDir: URL
    ) throws {
        let content = generatePackageSwift(
            packageInfo: packageInfo,
            builtTargets: Set(builtProducts)
        )
        
        let packageSwiftURL = outputDir.appendingPathComponent("Package.swift")
        try content.write(to: packageSwiftURL, atomically: true, encoding: .utf8)
    }
    
    private func generatePackageSwift(
        packageInfo: PackageInfo,
        builtTargets: Set<String>
    ) -> String {
        var lines: [String] = []
        
        // Header
        lines.append("// swift-tools-version: \(packageInfo.toolsVersion)")
        lines.append("// AUTO-GENERATED by swift-binify - Prebuilt binary package")
        lines.append("import PackageDescription")
        lines.append("")
        
        // Package declaration
        lines.append("let package = Package(")
        lines.append("    name: \"\(packageInfo.name)\",")
        
        // Platforms
        if !packageInfo.platforms.isEmpty {
            let platformDecls = packageInfo.platforms
                .sorted { $0.rawValue < $1.rawValue }
                .map { $0.swiftPlatformDeclaration }
                .joined(separator: ", ")
            lines.append("    platforms: [\(platformDecls)],")
        }
        
        // Products - expose products whose targets were built
        // Each product maps to the binary targets that were built
        lines.append("    products: [")
        
        // Find products that have at least one built target
        let exposableProducts = packageInfo.products.filter { product in
            product.isLibrary && product.targets.contains { builtTargets.contains($0) }
        }
        
        for (index, product) in exposableProducts.enumerated() {
            let comma = index < exposableProducts.count - 1 ? "," : ""
            // Map to the built binary targets
            let targetRefs = product.targets
                .filter { builtTargets.contains($0) }
                .map { "\"\($0)\"" }
                .joined(separator: ", ")
            lines.append("        .library(name: \"\(product.name)\", targets: [\(targetRefs)])\(comma)")
        }
        lines.append("    ],")
        
        // Dependencies - reference other prebuilt packages in /tmp/swift-binify-dylibs/
        if !packageInfo.dependencies.isEmpty {
            lines.append("    dependencies: [")
            for (index, dep) in packageInfo.dependencies.enumerated() {
                let comma = index < packageInfo.dependencies.count - 1 ? "," : ""
                lines.append("        .package(path: \"\(dylibsPath)/\(dep.identity)\")\(comma)")
            }
            lines.append("    ],")
        }
        
        // Targets - binary targets for each built target
        lines.append("    targets: [")
        let sortedTargets = builtTargets.sorted()
        for (index, targetName) in sortedTargets.enumerated() {
            let comma = index < sortedTargets.count - 1 ? "," : ""
            lines.append("        .binaryTarget(")
            lines.append("            name: \"\(targetName)\",")
            lines.append("            path: \"\(targetName).xcframework\"")
            lines.append("        )\(comma)")
        }
        lines.append("    ]")
        
        lines.append(")")
        lines.append("")
        
        return lines.joined(separator: "\n")
    }
}
