import Foundation

/// Generates a Package.swift that wraps built xcframeworks
struct PackageGenerator {

    /// Generate a Package.swift for the built xcframeworks
    /// - Parameters:
    ///   - packageInfo: The analyzed package info
    ///   - builtProducts: Names of the successfully built targets/xcframeworks
    ///   - outputDir: Where to write the Package.swift
    func generate(
        packageInfo: PackageInfo,
        builtProducts: [String],
        outputDir: URL
    ) throws {
        let content = generatePackageSwift(
            packageInfo: packageInfo,
            builtTargets: Set(builtProducts)
        )

        let packageSwiftURL = outputDir.appendingPathComponent("Package.swift")
        try content.write(to: packageSwiftURL, atomically: true, encoding: .utf8)
    }

    // MARK: - Private Helpers

    private func generatePackageSwift(
        packageInfo: PackageInfo,
        builtTargets: Set<String>
    ) -> String {
        var lines: [String] = []

        appendHeader(to: &lines, toolsVersion: packageInfo.toolsVersion)
        appendPackageDeclaration(to: &lines, name: packageInfo.name)
        appendPlatforms(to: &lines, platformVersions: packageInfo.platformVersions)
        appendProducts(to: &lines, products: packageInfo.products, builtTargets: builtTargets)
        appendDependencies(to: &lines, dependencies: packageInfo.dependencies)
        appendTargets(to: &lines, builtTargets: builtTargets)
        appendFooter(to: &lines)

        return lines.joined(separator: "\n")
    }

    private func appendHeader(to lines: inout [String], toolsVersion: String) {
        lines.append("// swift-tools-version: \(toolsVersion)")
        lines.append("// AUTO-GENERATED by swift-binify - Prebuilt binary package")
        lines.append("import PackageDescription")
        lines.append("")
    }

    private func appendPackageDeclaration(to lines: inout [String], name: String) {
        lines.append("let package = Package(")
        lines.append("    name: \"\(name)\",")
    }

    private func appendPlatforms(to lines: inout [String], platformVersions: [PlatformVersion]) {
        guard !platformVersions.isEmpty else { return }

        let platformDecls = platformVersions
            .sorted { $0.platform.rawValue < $1.platform.rawValue }
            .map { $0.swiftDeclaration }
            .joined(separator: ", ")
        lines.append("    platforms: [\(platformDecls)],")
    }

    private func appendProducts(
        to lines: inout [String],
        products: [PackageInfo.Product],
        builtTargets: Set<String>
    ) {
        lines.append("    products: [")

        // Find products that have at least one built target
        let exposableProducts = products.filter { product in
            product.isLibrary && product.targets.contains { builtTargets.contains($0) }
        }

        for (index, product) in exposableProducts.enumerated() {
            let comma = index < exposableProducts.count - 1 ? "," : ""
            // Map to the built binary targets
            let targetRefs = product.targets
                .filter { builtTargets.contains($0) }
                .map { "\"\($0)\"" }
                .joined(separator: ", ")
            lines.append("        .library(name: \"\(product.name)\", targets: [\(targetRefs)])\(comma)")
        }
        lines.append("    ],")
    }

    private func appendDependencies(to lines: inout [String], dependencies: [PackageInfo.Dependency]) {
        guard !dependencies.isEmpty else { return }

        lines.append("    dependencies: [")
        for (index, dep) in dependencies.enumerated() {
            let comma = index < dependencies.count - 1 ? "," : ""
            lines.append("        .package(path: \"\(Constants.outputBasePath)/\(dep.identity)\")\(comma)")
        }
        lines.append("    ],")
    }

    private func appendTargets(to lines: inout [String], builtTargets: Set<String>) {
        lines.append("    targets: [")
        let sortedTargets = builtTargets.sorted()
        for (index, targetName) in sortedTargets.enumerated() {
            let comma = index < sortedTargets.count - 1 ? "," : ""
            lines.append("        .binaryTarget(")
            lines.append("            name: \"\(targetName)\",")
            lines.append("            path: \"\(targetName).xcframework\"")
            lines.append("        )\(comma)")
        }
        lines.append("    ]")
    }

    private func appendFooter(to lines: inout [String]) {
        lines.append(")")
        lines.append("")
    }
}
